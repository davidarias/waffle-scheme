(module core)


(defun append (xs ys)
    (if (null? xs)
        ys
        (cons (car xs) (append (cdr xs) ys))))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun caar (x) (car (car x)))
(defun cddr (x) (cdr (cdr x)))
(defun cadar (x) (car (cdr (car x))))

(defun transfer (ls)
    (if (pair? ls)
        (if (pair? (car ls))
            (if (eq? (caar ls) 'unquote)
                (list 'cons (cadar ls) (transfer (cdr ls)))
                (if (eq? (caar ls) 'unquote-splicing)
                    (list 'append (cadar ls) (transfer (cdr ls)))
                    (list 'cons (transfer (car ls)) (transfer (cdr ls)))))
            (list 'cons (list 'quote (car ls)) (transfer (cdr ls))))
        (list 'quote ls)))


(defun map (fn ls)
    (if (null? ls)
        '()
        (cons (fn (car ls)) (map fn (cdr ls)))))

(defmacro quasiquote (x) (transfer x))
(defmacro let (bindings . body) 
	`((lambda ,(map car bindings) ,@body) 
		,@(map cadr bindings)))
(defmacro let* (bindings . body)
	(if (null? bindings)
		`(begin ,@body)
		`(let (,(car bindings))
			(let* ,(cdr bindings) ,@body))))
(defmacro letrec (bindings . body)
	`(let ,(map (lambda (v) (list (car v) nil)) bindings)
		,@(map (lambda (v) `(set! ,@v)) bindings)
		,@body))
(export append cadr cdar caar cddr transfer map)